#!/usr/bin/env python3
"""
Convert Xcel Energy CSV downloads to Prometheus textfile collector format.

Reads the latest CSV files produced by xcel_download_elec_daily.py and
(optionally) xcel_download_gas_monthly.py and writes xcel_energy.prom to
PROM_DIR for consumption by node_exporter's textfile collector.

Environment variables:
  XCEL_DATA_DIR   Directory containing the downloaded CSV files
                  (default: ./xcel_data)
  PROM_DIR        Output directory for the .prom file
                  (default: same as XCEL_DATA_DIR)
                  On Linux with node_exporter set to:
                  /var/lib/node_exporter/textfile_collector/

Metrics written:
  xcel_energy_daily_kwh{period,date}          By Day kWh (30-day billing period)
  xcel_energy_daily_cost_dollars{period,date} By Day cost in USD
  xcel_energy_monthly_kwh{period,date}        By Month kWh (optional)
  xcel_energy_monthly_cost_dollars{period,date} By Month cost in USD (optional)
  xcel_bill_electric_dollars{date}            Electric bill amount per billing cycle (optional)
  xcel_bill_gas_dollars{date}                 Gas bill amount per billing cycle (optional)
  xcel_energy_last_updated_seconds            Unix timestamp of last download run
  xcel_gas_monthly_therms{date}               Monthly gas usage in therms (optional)
  xcel_gas_monthly_cost_dollars{date}         Monthly gas cost in USD (optional)
  xcel_energy_ondemand_kwh{datetime}          On-demand 30-min interval kWh (optional)

Usage:
  python xcel_to_prom.py
  # or import and call generate_prom() from another script
"""

from __future__ import annotations

import csv
import os
import sys
from pathlib import Path

from dotenv import load_dotenv

load_dotenv()

DATA_DIR = Path(os.getenv("XCEL_DATA_DIR", "./xcel_data"))
PROM_DIR = Path(os.getenv("PROM_DIR", str(DATA_DIR)))


def _latest(pattern: str, directory: Path) -> Path | None:
    """Return the most recently modified file matching glob pattern."""
    matches = sorted(
        directory.glob(pattern),
        key=lambda p: p.stat().st_mtime,
        reverse=True,
    )
    return matches[0] if matches else None


def generate_prom(
    data_dir: Path = DATA_DIR,
    prom_dir: Path = PROM_DIR,
) -> Path:
    """
    Read the latest CSV files from data_dir and write xcel_energy.prom to
    prom_dir.  Returns the path to the written .prom file.
    """
    kwh_csv  = _latest("byday_kwh_*.csv",  data_dir)
    cost_csv = _latest("byday_cost_*.csv", data_dir)

    # Monthly electric CSVs are optional — generated by xcel_download_elec_monthly.py
    elec_monthly_kwh_csv  = _latest("bymonth_elec_kwh_*.csv",  data_dir)
    elec_monthly_cost_csv = _latest("bymonth_elec_cost_*.csv", data_dir)

    # Bill history CSV is optional — generated by xcel_download_bill_history.py
    bill_csv = _latest("bill_summary_*.csv", data_dir)

    # Gas CSVs are optional — generated by xcel_download_gas_monthly.py
    gas_usage_csv = _latest("bymonth_gas_usage_*.csv", data_dir)
    gas_cost_csv  = _latest("bymonth_gas_cost_*.csv",  data_dir)

    # On-demand CSV is optional — generated by xcel_download_ondemand.py
    ondemand_csv = _latest("ondemand_*.csv", data_dir)

    missing = [
        name for name, f in [
            ("byday_kwh",  kwh_csv),
            ("byday_cost", cost_csv),
        ]
        if f is None
    ]
    if missing:
        raise FileNotFoundError(
            f"No CSV files found for: {', '.join(missing)}. "
            "Run xcel_download_elec_daily.py first."
        )

    lines: list[str] = []

    def lbl(s: str) -> str:
        """Normalize column name to a Prometheus label value."""
        return s.lower().replace(" ", "_")

    # ── By Day kWh ────────────────────────────────────────────────────────────
    lines += [
        "# HELP xcel_energy_daily_kwh"
        " Daily electricity usage in kWh by time-of-use period",
        "# TYPE xcel_energy_daily_kwh gauge",
    ]
    with kwh_csv.open(encoding="utf-8") as f:
        for row in csv.DictReader(f):
            date = row["Date"]
            for col in ("On Peak", "Off Peak", "Total"):
                lines.append(
                    f'xcel_energy_daily_kwh{{period="{lbl(col)}",'
                    f'date="{date}"}} {row[col]}'
                )
    lines.append("")

    # ── By Day cost ───────────────────────────────────────────────────────────
    lines += [
        "# HELP xcel_energy_daily_cost_dollars"
        " Daily electricity cost in USD by time-of-use period",
        "# TYPE xcel_energy_daily_cost_dollars gauge",
    ]
    with cost_csv.open(encoding="utf-8") as f:
        for row in csv.DictReader(f):
            date = row["Date"]
            for col in ("On Peak", "Off Peak", "Total"):
                lines.append(
                    f'xcel_energy_daily_cost_dollars{{period="{lbl(col)}",'
                    f'date="{date}"}} {row[col]}'
                )
    lines.append("")

    # ── Monthly electric kWh (optional) ──────────────────────────────────────
    if elec_monthly_kwh_csv:
        lines += [
            "# HELP xcel_energy_monthly_kwh"
            " Monthly electricity usage in kWh by time-of-use period",
            "# TYPE xcel_energy_monthly_kwh gauge",
        ]
        with elec_monthly_kwh_csv.open(encoding="utf-8") as f:
            for row in csv.DictReader(f):
                date = row["Date"]
                for col in ("On Peak", "Off Peak", "Total"):
                    lines.append(
                        f'xcel_energy_monthly_kwh{{period="{lbl(col)}",'
                        f'date="{date}"}} {row[col]}'
                    )
        lines.append("")

    # ── Monthly electric cost (optional) ──────────────────────────────────────
    if elec_monthly_cost_csv:
        lines += [
            "# HELP xcel_energy_monthly_cost_dollars"
            " Monthly electricity cost in USD by time-of-use period",
            "# TYPE xcel_energy_monthly_cost_dollars gauge",
        ]
        with elec_monthly_cost_csv.open(encoding="utf-8") as f:
            for row in csv.DictReader(f):
                date = row["Date"]
                for col in ("On Peak", "Off Peak", "Total"):
                    lines.append(
                        f'xcel_energy_monthly_cost_dollars{{period="{lbl(col)}",'
                        f'date="{date}"}} {row[col]}'
                    )
        lines.append("")

    # ── Bill history (optional) ───────────────────────────────────────────────
    if bill_csv:
        elec_bill_lines: list[str] = []
        gas_bill_lines:  list[str] = []
        with bill_csv.open(encoding="utf-8") as f:
            for row in csv.DictReader(f):
                date  = row["Date"]
                elec  = float(row["Electric Charges"] or 0)
                gas   = float(row["Gas Charges"] or 0)
                if elec:
                    elec_bill_lines.append(
                        f'xcel_bill_electric_dollars{{date="{date}"}} {elec}'
                    )
                if gas:
                    gas_bill_lines.append(
                        f'xcel_bill_gas_dollars{{date="{date}"}} {gas}'
                    )
        if elec_bill_lines:
            lines += [
                "# HELP xcel_bill_electric_dollars Electric bill amount per billing cycle",
                "# TYPE xcel_bill_electric_dollars gauge",
            ] + elec_bill_lines + [""]
        if gas_bill_lines:
            lines += [
                "# HELP xcel_bill_gas_dollars Gas bill amount per billing cycle",
                "# TYPE xcel_bill_gas_dollars gauge",
            ] + gas_bill_lines + [""]

    # ── Monthly gas usage (optional) ─────────────────────────────────────────
    if gas_usage_csv:
        lines += [
            "# HELP xcel_gas_monthly_therms"
            " Monthly gas usage in therms",
            "# TYPE xcel_gas_monthly_therms gauge",
        ]
        with gas_usage_csv.open(encoding="utf-8") as f:
            for row in csv.DictReader(f):
                lines.append(
                    f'xcel_gas_monthly_therms{{date="{row["Date"]}"}} {row["Therms"]}'
                )
        lines.append("")

    # ── Monthly gas cost (optional) ───────────────────────────────────────────
    if gas_cost_csv:
        lines += [
            "# HELP xcel_gas_monthly_cost_dollars"
            " Monthly gas cost in USD",
            "# TYPE xcel_gas_monthly_cost_dollars gauge",
        ]
        with gas_cost_csv.open(encoding="utf-8") as f:
            for row in csv.DictReader(f):
                lines.append(
                    f'xcel_gas_monthly_cost_dollars{{date="{row["Date"]}"}} {row["Cost"]}'
                )
        lines.append("")

    # ── On-demand 15-min intervals (optional) ────────────────────────────────
    # Uses explicit millisecond timestamps so Grafana can display as time series.
    if ondemand_csv:
        lines += [
            "# HELP xcel_energy_ondemand_kwh"
            " On-demand 15-minute interval electricity usage in kWh",
            "# TYPE xcel_energy_ondemand_kwh gauge",
        ]
        with ondemand_csv.open(encoding="utf-8") as f:
            for row in csv.DictReader(f):
                lines.append(
                    f'xcel_energy_ondemand_kwh{{rate_level="{row["rate_level"]}"}} '
                    f'{row["kWh"]} {row["unix_ms"]}'
                )
        lines.append("")

    # ── Metadata ──────────────────────────────────────────────────────────────
    lines += [
        "# HELP xcel_energy_last_updated_seconds"
        " Unix timestamp when Xcel Energy data was last downloaded",
        "# TYPE xcel_energy_last_updated_seconds gauge",
        f"xcel_energy_last_updated_seconds {int(kwh_csv.stat().st_mtime)}",
        "",
    ]

    prom_dir.mkdir(parents=True, exist_ok=True)
    out = prom_dir / "xcel_energy.prom"
    out.write_text("\n".join(lines), encoding="utf-8")
    return out


if __name__ == "__main__":
    try:
        out = generate_prom()
        text = out.read_text(encoding="utf-8")
        samples = sum(1 for l in text.splitlines() if l and not l.startswith("#"))
        print(f"Written: {out}  ({samples} samples)")
    except Exception as e:
        print(f"Failed: {e}", file=sys.stderr)
        sys.exit(1)
